"""
This type stub file was generated by pyright.
"""

import anyio
from collections.abc import Awaitable, Callable
from typing import Any, TYPE_CHECKING, overload
from anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream
from sekaibot.adapter import Adapter
from sekaibot.internal.event import Event, EventHandleOption
from sekaibot.internal.node import Node
from sekaibot.typing import EventT, StateT
from sekaibot.bot import Bot

"""SekaiBot 事件分配类"""
if TYPE_CHECKING:
    ...
class NodeManager:
    """事件分配类"""
    bot: Bot
    _condition: anyio.Condition
    _current_event: Event[Adapter[Any, Any]] | None
    _event_send_stream: MemoryObjectSendStream[EventHandleOption]
    _event_receive_stream: MemoryObjectReceiveStream[EventHandleOption]
    def __init__(self, bot: Bot) -> None:
        ...
    
    async def startup(self) -> None:
        """初始化事件分配器"""
        ...
    
    async def run(self) -> None:
        """运行事件分配器"""
        ...
    
    async def safe_run(self) -> None:
        """安全运行事件分配器"""
        ...
    
    async def handle_event(self, current_event: Event[Any], *, handle_get: bool = ..., show_log: bool = ...) -> None:
        """被适配器对象调用，根据优先级分发事件给所有插件，并处理插件的 `stop` 、 `skip` 等信号。

        此方法不应该被用户手动调用。

        Args:
            current_event: 当前待处理的 `Event`。
            handle_get: 当前事件是否可以被 get 方法捕获，默认为 `True`。
            show_log: 是否在日志中显示，默认为 `True`。
        """
        ...
    
    async def add_temporary_task(self, node_class: type[Node[Any, Any, Any]], current_event: Event[Any], state: StateT, max_try_times: int | None = ..., timeout: float = ...) -> None:
        """添加一个临时节点任务，在调用 reject 时运行。

        Args:
            node_class: 要添加的节点，必须是类实例。
            current_event: 当前事件。
            state: 节点状态。
            max_try_times: 最大事件数。
            timeout: 超时时间。
        """
        ...
    
    async def shutdown(self) -> None:
        """关闭并清理事件。"""
        ...
    
    @overload
    async def get(self, func: Callable[[Event[Any]], bool | Awaitable[bool]] | None = ..., *, event_type: None = ..., adapter_type: None = ..., max_try_times: int | None = ..., timeout: float | None = ...) -> Event[Any]:
        ...
    
    @overload
    async def get(self, func: Callable[[EventT], bool | Awaitable[bool]] | None = ..., *, event_type: None = ..., adapter_type: type[Adapter[EventT, Any]], max_try_times: int | None = ..., timeout: float | None = ...) -> EventT:
        ...
    
    @overload
    async def get(self, func: Callable[[EventT], bool | Awaitable[bool]] | None = ..., *, event_type: type[EventT], adapter_type: type[Adapter[Any, Any]] | None = ..., max_try_times: int | None = ..., timeout: float | None = ...) -> EventT:
        ...
    
    async def get(self, func: Callable[[Any], bool | Awaitable[bool]] | None = ..., *, event_type: type[Event[Any]] | None = ..., adapter_type: type[Adapter[Any, Any]] | None = ..., max_try_times: int | None = ..., timeout: float = ...) -> Event[Any]:
        """获取满足指定条件的的事件，协程会等待直到适配器接收到满足条件的事件、超过最大事件数或超时。

        Args:
            func: 协程或者函数，函数会被自动包装为协程执行。
                要求接受一个事件作为参数，返回布尔值。当协程返回 `True` 时返回当前事件。
                当为 `None` 时相当于输入对于任何事件均返回真的协程，即返回适配器接收到的下一个事件。
            event_type: 当指定时，只接受指定类型的事件，先于 func 条件生效。默认为 `None`。
            adapter_type: 当指定时，只接受指定适配器产生的事件，先于 func 条件生效。默认为 `None`。
            max_try_times: 最大事件数。
            timeout: 超时时间。

        Returns:
            返回满足 `func` 条件的事件。

        Raises:
            GetEventTimeout: 超过最大事件数或超时。
        """
        ...
    


