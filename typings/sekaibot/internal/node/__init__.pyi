"""
This type stub file was generated by pyright.
"""

import inspect
import anyio
from contextlib import AsyncExitStack, suppress
from enum import Enum
from types import UnionType
from typing import Annotated, Any, ClassVar, Generic, NoReturn, TYPE_CHECKING, TypeVar, cast, final, get_args, get_origin
from exceptiongroup import catch
from sekaibot.config import ConfigModel
from sekaibot.consts import JUMO_TO_TARGET, MAX_TIMEOUT, REJECT_TARGET
from sekaibot.dependencies import Dependency, Depends, solve_dependencies_in_bot
from sekaibot.exceptions import FinishException, JumpToException, PruningException, RejectException, SkipException, StopException
from sekaibot.internal.event import Event
from sekaibot.internal.message import BuildMessageType
from sekaibot.internal.permission import Permission
from sekaibot.internal.rule import Rule
from sekaibot.log import logger
from sekaibot.typing import ConfigT, EventT, GlobalStateT, NameT, NodeStateT, StateT
from sekaibot.utils import flatten_exception_group, handle_exception, is_config_class
from sekaibot.bot import Bot

"""SekaiBot 节点。

所有 SekaiBot 节点的基类。所有用户编写的节点必须继承自 `Node` 类。
"""
if TYPE_CHECKING:
    ...
_T = TypeVar("_T")
__all__ = ["Node", "NodeLoadType"]
class NodeLoadType(Enum):
    """节点加载类型。"""
    DIR = ...
    NAME = ...
    FILE = ...
    CLASS = ...


class Node(Generic[EventT, NodeStateT, ConfigT]):
    """所有 SekaiBot 节点的基类。

    Attributes:
        parent: 节点的父节点名称。
        EventType: 节点处理的事件类型。
        Config: 节点的配置类。
        state: 节点的状态。
        bot: 节点所在的 Bot 实例。
        event: 当前正在被此节点处理的事件。
        priority: 节点的优先级，数字越小表示优先级越高，默认为 0。
        block: 节点执行结束后是否阻止事件的传播。`True` 表示阻止。
        load: 节点是否被加载，默认为 `True`，等同于使用以 `_` 开头的节点名。
        __node_load_type__: 节点加载类型，由 SekaiBot 自动设置，反映了此节点是如何被加载的。
        __node_file_path__: 当节点加载类型为 `NodeLoadType.CLASS` 时为 `None`，
            否则为定义节点在的 Python 模块的位置。
    """
    parent: ClassVar[str | None] = ...
    priority: ClassVar[int] = ...
    block: ClassVar[bool] = ...
    load: ClassVar[bool] = ...
    __node_rule__: Rule = ...
    __node_perm__: Permission = ...
    __node_load_type__: ClassVar[NodeLoadType]
    __node_file_path__: ClassVar[str | None]
    EventType: str | type[Event[Any]]
    Config: type[ConfigT]
    if TYPE_CHECKING:
        event: EventT
        state: StateT
        ...
    else:
        ...
    def __init_state__(self) -> NodeStateT | None:
        """初始化节点状态。"""
        ...
    
    def __init_subclass__(cls, event_type: type[EventT] | None = ..., config: type[ConfigT] | None = ..., init_state: NodeStateT | None = ..., **_kwargs: Any) -> None:
        """初始化子类。

        Args:
            event_type: 事件类型。
            config: 配置类。
            init_state: 初始状态。
        """
        ...
    
    @final
    @property
    def name(self) -> str:
        """节点类名称。"""
        ...
    
    @final
    @property
    def bot(self) -> Bot:
        """机器人"""
        ...
    
    @final
    @property
    def config(self) -> ConfigT:
        """节点配置。"""
        ...
    
    @property
    def node_state(self) -> NodeStateT:
        """节点状态。"""
        ...
    
    @node_state.setter
    @final
    def node_state(self, value: NodeStateT) -> None:
        ...
    
    @property
    def global_state(self) -> dict[Any, Any]:
        """通用状态。"""
        ...
    
    @global_state.setter
    @final
    def global_state(self, value: dict[Any, Any]) -> None:
        ...
    
    async def handle(self) -> None:
        """处理事件的方法。当 `rule()` 方法返回 `True` 时 SekaiBot 会调用此方法。每个节点必须实现此方法。"""
        ...
    
    async def rule(self) -> bool:
        """匹配事件的方法。事件处理时，会按照节点的优先级依次调用此方法，当此方法返回 `True` 时将事件交由此节点处理。每个节点不一定要实现此方法。

        注意：不建议直接在此方法内实现对事件的处理，事件的具体处理请交由 handle 方法。
        """
        ...
    
    async def fallback(self) -> None:
        """事件不通过时执行的善后方法。当 `rule()` 方法返回 `False` 时 SekaiBot 会调用此方法。每个节点不一定要实现此方法。

        注意：不建议直接在此方法内实现对事件的处理，事件的具体处理请交由 handle 方法。
        """
        ...
    
    @final
    async def reply(self, message: BuildMessageType[Any], **params: Any) -> None:
        """回复消息。"""
        ...
    
    @final
    async def get(self, *, max_try_times: int | None = ..., timeout: float = ...) -> EventT:
        """获取用户回复消息。

        相当于 `Bot` 的 `get()`，条件为适配器、事件类型、发送人相同。

        Args:
            max_try_times: 最大事件数。
            timeout: 超时时间。

        Returns:
            用户回复的消息事件。

        Raises:
            GetEventTimeout: 超过最大事件数或超时。
        """
        ...
    
    @final
    async def ask(self, message: str, max_try_times: int | None = ..., timeout: float = ...) -> EventT:
        """询问消息。

        表示回复一个消息后获取用户的回复。
        相当于 `reply()` 后执行 `get()`。

        Args:
            message: 回复消息的内容。
            max_try_times: 最大事件数。
            timeout: 超时时间。

        Returns:
            用户回复的消息事件。
        """
        ...
    
    @final
    def stop(self) -> NoReturn:
        """停止当前事件传播。"""
        ...
    
    @final
    def skip(self) -> NoReturn:
        """跳过自身继续当前事件传播。"""
        ...
    
    @final
    def jump_to(self, node: str) -> NoReturn:
        """跳过自身并将事件转发到下一个节点。"""
        ...
    
    @final
    def prune(self) -> NoReturn:
        """中断事件的传播并将事件转发到下一个节点，即剪枝。"""
        ...
    
    @final
    async def finish(self, message: BuildMessageType[Any] | None = ...) -> NoReturn:
        """结束当前节点。"""
        ...
    
    @final
    async def reject(self, message: BuildMessageType[Any] | None = ..., max_try_times: int | None = ..., timeout: float = ...) -> NoReturn:
        """拒绝当前事件"""
        ...
    
    @final
    async def call_api(self, api: str, **params: Any) -> Any:
        """调用 API，协程会等待直到获得 API 响应。

        Args:
            api: API 名称。
            **params: API 参数。

        Returns:
            API 响应中的 data 字段。

        Raises:
            NetworkError: 网络错误。
            ApiNotAvailable: API 请求响应 404， API 不可用。
            ActionFailed: API 请求响应 failed， API 操作失败。
            ApiTimeout: API 请求响应超时。
        """
        ...
    
    @final
    async def run(self, dependent: Dependency[_T]) -> _T | None:
        """在节点内运行 SekaiBot 内置的，或自定义的函数，以及具有 `__call__` 的类。

        这些函数只能含有 Bot, Event, State 三个参数。
        """
        ...
    
    @final
    async def gather(self, *dependencies: Dependency[Any], return_exceptions: bool = ...) -> tuple[Any, ...]:
        """类似 `asyncio.gather()` 并发执行多个任务，支持 `return_exceptions`"""
        ...
    


