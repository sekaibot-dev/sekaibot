"""
This type stub file was generated by pyright.
"""

from abc import ABC, abstractmethod
from collections.abc import ItemsView, Iterable, Iterator, KeysView, Mapping, ValuesView
from typing import Any, Generic, Literal, Self, SupportsIndex, Type, TypeVar, overload
from typing_extensions import override
from pydantic import BaseModel, GetCoreSchemaHandler
from pydantic_core import core_schema

"""SekaiBot 消息。

实现了常用的基本消息 `Message` 和消息字段 `MessageSegment` 模型供适配器使用。
适配器开发者可以根据需要实现此模块中消息类的子类或定义与此不同的消息类型，但建议若可行的话应尽量使用此模块中消息类的子类。
"""
__all__ = ["BuildMessageType", "Message", "MessageSegment", "MessageSegmentT", "MessageT"]
MessageT = TypeVar("MessageT", bound="Message[Any]")
MessageSegmentT = TypeVar("MessageSegmentT", bound="MessageSegment[Any]")
BuildMessageType = Iterable[MessageSegmentT] | MessageSegmentT | str | Mapping[str, Any]
class Message(ABC, list[MessageSegmentT], Generic[MessageSegmentT]):
    """消息。

    本类是 `list` 的子类，并重写了 `__init__()` 方法，
    可以直接处理 `str`, `Mapping`, `MessageSegment`, `list[MessageSegment]`。
    本类重载了 `+` 和 `+=` 运算符，可以直接和 `Message`, `MessageSegment` 等类型的对象执行取和运算。
    适配器开发者需要继承本类并重写 `get_segment_class()` 方法。
    """
    def __init__(self, *messages: BuildMessageType[MessageSegmentT]) -> None:
        """初始化。

        Args:
            *messages: 可以被转化为消息的数据。
        """
        ...
    
    @classmethod
    @abstractmethod
    def get_segment_class(cls) -> type[MessageSegmentT]:
        """获取消息字段类。

        Returns:
            消息字段类。
        """
        ...
    
    @classmethod
    def __get_pydantic_core_schema__(cls, _source: type[Any], handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:
        """Pydantic 自定义模式。"""
        ...
    
    @override
    def __repr__(self) -> str:
        """返回消息的描述。

        Returns:
            消息的描述。
        """
        ...
    
    @override
    def __str__(self) -> str:
        """返回消息的文本表示。

        Returns:
            消息的文本表示。
        """
        ...
    
    @override
    def __eq__(self, other: str | BuildMessageType[MessageSegmentT] | Any) -> bool:
        """判断消息是否等于另一消息。

        Args:
            other: 其他对象。

        Returns:
            消息是否等于另一消息。
        """
        ...
    
    @override
    def __ne__(self, other: str | BuildMessageType[MessageSegmentT] | Any) -> bool:
        """判断消息是否不等于另一消息。

        Args:
            other: 其他对象。

        Returns:
            消息是否不等于另一消息。
        """
        ...
    
    @override
    def __contains__(self, item: object) -> bool:
        """判断消息中是否包含指定文本或消息字段。

        Args:
            item: 文本或消息字段。

        Returns:
            消息中是否包含指定文本或消息字段。
        """
        ...
    
    def __add__(self, other: BuildMessageType[MessageSegmentT]) -> Self:
        """自定义消息与其他对象相加的方法。

        Args:
            other: 其他对象。

        Returns:
            相加的结果。
        """
        ...
    
    def __radd__(self, other: BuildMessageType[MessageSegmentT]) -> Self:
        """自定义消息与其他对象相加的方法。

        Args:
            other: 其他对象。

        Returns:
            相加的结果。
        """
        ...
    
    def __iadd__(self, other: BuildMessageType[MessageSegmentT]) -> Self:
        """自定义消息与其他对象相加的方法。

        Args:
            other: 其他对象。

        Returns:
            相加的结果。
        """
        ...
    
    def is_text(self) -> bool:
        """是否是纯文本消息。"""
        ...
    
    def get_plain_text(self) -> str:
        """获取消息中的纯文本部分。

        Returns:
            消息中的纯文本部分。
        """
        ...
    
    def filter_message(self, include: set[str] | None = ..., exclude: set[str] | None = ...) -> Message[MessageSegmentT]:
        """获取消息中某一类型的部分。

        Returns:
            消息中某一类型的部分。
        """
        ...
    
    @override
    def copy(self) -> Self:
        """返回自身的浅复制。

        Returns:
            自身的浅复制。
        """
        ...
    
    @overload
    def startswith(self, prefix: str | MessageSegmentT | tuple[str | MessageSegmentT, ...], start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., ignorecase: bool = ..., *, return_key: Literal[False] = ...) -> bool:
        ...
    
    @overload
    def startswith(self, prefix: str | MessageSegmentT | tuple[str | MessageSegmentT, ...], start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., ignorecase: bool = ..., *, return_key: Literal[True] = ...) -> str | MessageSegmentT | None:
        ...
    
    def startswith(self, prefix: str | MessageSegmentT | tuple[str | MessageSegmentT, ...], start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., ignorecase: bool = ..., *, return_key: bool = ..., default: str | MessageSegmentT | None = ...) -> bool | str | MessageSegmentT | None:
        """实现类似字符串的 `startswith()` 方法。

        当 `prefix` 类型是 `str` 时，会将自身转换为 `str` 类型，再调用 `str` 类型的 `startswith()` 方法。
        当 `prefix` 类型是 `MessageSegment` 时，`start` 和 `end` 参数将不其作用，
            会判断列表的第一个消息字段是否和 `prefix` 相等。

        Args:
            prefix: 前缀。
            start: 开始检查位置。
            end: 停止检查位置。
            ignorecase: 是否忽略大小写
            return_key: 是否返回捕获的 key
            default: 若未捕获返回的值

        Returns:
            检查结果。
        """
        ...
    
    @overload
    def endswith(self, suffix: str | MessageSegmentT | tuple[str | MessageSegmentT, ...], start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., ignorecase: bool = ..., *, return_key: Literal[False] = ...) -> bool:
        ...
    
    @overload
    def endswith(self, suffix: str | MessageSegmentT | tuple[str | MessageSegmentT, ...], start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., ignorecase: bool = ..., *, return_key: Literal[True] = ...) -> str | MessageSegmentT | None:
        ...
    
    def endswith(self, suffix: str | MessageSegmentT | tuple[str | MessageSegmentT, ...], start: SupportsIndex | None = ..., end: SupportsIndex | None = ..., ignorecase: bool = ..., *, return_key: bool = ..., default: str | MessageSegmentT | None = ...) -> bool | str | MessageSegmentT | None:
        """实现类似字符串的 `endswith()` 方法。

        当 `suffix` 类型是 `str` 时，会将自身转换为 `str` 类型，再调用 `str` 类型的 `endswith()` 方法。
        当 `suffix` 类型是 MessageSegment 时，`start` 和 `end` 参数将不其作用，
            会判断列表的最后一个消息字段是否和 `suffix` 相等。

        Args:
            suffix: 后缀。
            start: 开始检查位置。
            end: 停止检查位置。
            ignorecase: 是否忽略大小写
            return_key: 是否返回捕获的 key
            default: 若未捕获返回的值

        Returns:
            检查结果。
        """
        ...
    
    @overload
    def replace(self, old: str, new: str, count: int = ...) -> Self:
        ...
    
    @overload
    def replace(self, old: MessageSegmentT, new: MessageSegmentT | None, count: int = ...) -> Self:
        ...
    
    def replace(self, old: str | MessageSegmentT, new: str | MessageSegmentT | None, count: int = ...) -> Self:
        """实现类似字符串的 `replace()` 方法。

        当 `old` 为 `str` 类型时，`new` 也必须是 `str`，本方法将仅对 `is_text()` 为 `True` 的消息字段进行处理。
        当 `old` 为 MessageSegment 类型时，`new` 可以是 `MessageSegment` 或 `None`，本方法将对所有消息字段进行处理，
            并替换符合条件的消息字段。`None` 表示删除匹配到的消息字段。

        Args:
            old: 被匹配的字符串或消息字段。
            new: 被替换为的字符串或消息字段。
            count: 替换的次数。

        Returns:
            替换后的消息对象。
        """
        ...
    


class MessageSegment(ABC, BaseModel, Mapping[str, Any], Generic[MessageT]):
    """消息字段。

    本类实现了所有 `Mapping` 类型的方法，这些方法全部是对 `data` 属性的操作。
    本类重写了 `+` 和 `+=` 运算符，可以直接和 `Message`, `MessageSegment` 等类型的对象执行取和运算，返回 `Message` 对象。
    适配器开发者需要继承本类并重写 `get_message_class()` 方法。

    Attributes:
        type: 消息字段类型。
        data: 消息字段内容。
    """
    type: str
    data: dict[str, Any] = ...
    @classmethod
    @abstractmethod
    def get_message_class(cls) -> Type[MessageT]:
        """获取消息类。

        Returns:
            消息类。
        """
        ...
    
    @classmethod
    @abstractmethod
    def from_str(cls, msg: str) -> Self:
        """用于将 `str` 转换为消息字段，子类应重写此方法。

        Args:
            msg: 要解析为消息字段的数据。

        Returns:
            由 `str` 转换的消息字段。
        """
        ...
    
    @classmethod
    def from_mapping(cls, msg: Mapping[Any, Any]) -> Self:
        """用于将 `Mapping` 转换为消息字段。

        如有需要，子类可重写此方法以更改对 `Mapping` 的默认行为。

        Args:
            msg: 要解析为消息字段的数据。

        Returns:
            由 Mapping 转换的消息字段。
        """
        ...
    
    @override
    def __str__(self) -> str:
        """返回消息字段的文本表示。

        Returns:
            消息字段的文本表示。
        """
        ...
    
    @override
    def __repr__(self) -> str:
        """返回消息字段的描述。

        Returns:
            消息字段的描述。
        """
        ...
    
    @override
    def __hash__(self) -> int:
        """返回消息字段的哈希值。

        Returns:
            消息字段的哈希值。
        """
        ...
    
    @override
    def __getitem__(self, key: str) -> Any:
        """取索引。相当于对 `data` 属性进行此操作。

        Args:
            key: 键。

        Returns:
            `data` 字典对应索引的值。
        """
        ...
    
    def __setitem__(self, key: str, value: Any) -> None:
        """设置指定索引的值。相当于对 `data` 属性进行此操作。

        Args:
            key: 键。
            value: 值。
        """
        ...
    
    def __delitem__(self, key: str) -> None:
        """删除索引。相当于对 `data` 属性进行此操作。

        Args:
            key: 键。
        """
        ...
    
    @override
    def __len__(self) -> int:
        """取长度。相当于对 `data` 属性进行此操作。

        Returns:
            `data` 字典的长度。
        """
        ...
    
    def __iter__(self) -> Iterator[str]:
        """迭代。相当于对 `data` 属性进行此操作。

        Returns:
            `data` 字典的迭代器。
        """
        ...
    
    @override
    def __contains__(self, key: object) -> bool:
        """索引是否包含在对象内。相当于对 `data` 属性进行此操作。

        Args:
            key: 键。

        Returns:
            索引是否包含在 `data` 字典内。
        """
        ...
    
    @override
    def __eq__(self, other: object) -> bool:
        """判断是否相等。允许在定义自字段时覆写，已适配QQ图片id不相等，而unique相等的情况。

        Args:
            other: 其他对象。

        Returns:
            是否相等。
        """
        ...
    
    @override
    def __ne__(self, other: object) -> bool:
        """判断是否不相等。

        Args:
            other: 其他对象。

        Returns:
            是否不相等。
        """
        ...
    
    def __add__(self, other: Any) -> MessageT:
        """自定义消息字段与其他对象相加的方法。

        Args:
            other: 其他对象。

        Returns:
            相加的结果。
        """
        ...
    
    def __radd__(self, other: Any) -> MessageT:
        """自定义消息字段与其他对象相加的方法。

        Args:
            other: 其他对象。

        Returns:
            相加的结果。
        """
        ...
    
    @override
    def get(self, key: str, default: Any = ...) -> Any:
        """如果 `key` 存在于 `data` 字典中则返回 `key` 的值，否则返回 `default`。"""
        ...
    
    @override
    def keys(self) -> KeysView[str]:
        """返回由 `data` 字典键组成的一个新视图。"""
        ...
    
    @override
    def values(self) -> ValuesView[Any]:
        """返回由 `data` 字典值组成的一个新视图。"""
        ...
    
    @override
    def items(self) -> ItemsView[str, Any]:
        """返回由 `data` 字典项 (`(键, 值)` 对) 组成的一个新视图。"""
        ...
    
    def is_text(self) -> bool:
        """是否是纯文本消息字段。

        Returns:
            是否是纯文本消息字段。
        """
        ...
    


