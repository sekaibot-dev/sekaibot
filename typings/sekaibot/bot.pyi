"""
This type stub file was generated by pyright.
"""

import anyio
from pathlib import Path
from typing import Any, ClassVar, overload
from sekaibot.adapter import Adapter
from sekaibot.config import MainConfig
from sekaibot.internal.node import Node
from sekaibot.internal.node.manager import NodeManager
from sekaibot.plugin import Plugin
from sekaibot.typing import AdapterHook, AdapterT, BotHook, EventHook, NodeHook
from sekaibot.utils import ModulePathFinder, TreeType

"""SekaiBot 机器人对象。

SekaiBot 的基础模块，每一个 SekaiBot 机器人即是一个 `Bot` 实例。
"""
HANDLED_SIGNALS = ...
__all__ = ["Bot"]
class Bot:
    """SekaiBot 机器人对象，定义了机器人的基本方法。

    读取并储存配置 `Config`，加载适配器 `Adapter` 、节点 `Node` 和插件 `Plugin`，并进行事件分发。

    Attributes:
        config: 机器人配置。
        adapters: 当前已经加载的适配器的列表。
        nodes_list: 节点运行顺序表。
        node_state: 节点状态。
        plugin_dict: 插件存储字典。
        global_state: 全局状态。
    """
    config: MainConfig
    manager: NodeManager
    adapters: list[Adapter[Any, Any]]
    nodes_tree: TreeType[type[Node[Any, Any, Any]]]
    nodes_list: list[tuple[type[Node[Any, Any, Any]], int]]
    node_state: dict[str, Any]
    plugin_dict: dict[str, Plugin[Any]]
    global_state: dict[str, Any]
    _should_exit: anyio.Event
    _restart_flag: bool
    _module_path_finder: ModulePathFinder
    _raw_config_dict: dict[str, Any]
    _config_file: str | None
    _config_dict: dict[str, Any] | None
    _handle_signals: bool
    _extend_nodes: list[type[Node[Any, Any, Any]] | str | Path]
    _extend_node_dirs: list[Path]
    _extend_adapters: list[type[Adapter[Any, Any]] | str]
    _extend_plugins: ClassVar[list[type[Plugin[Any]]]] = ...
    _bot_startup_hooks: ClassVar[set[BotHook]] = ...
    _bot_run_hooks: ClassVar[set[BotHook]] = ...
    _bot_exit_hooks: ClassVar[set[BotHook]] = ...
    _adapter_startup_hooks: ClassVar[set[AdapterHook]] = ...
    _adapter_run_hooks: ClassVar[set[AdapterHook]] = ...
    _adapter_shutdown_hooks: ClassVar[set[AdapterHook]] = ...
    _event_preprocessor_hooks: ClassVar[set[EventHook]] = ...
    _event_postprocessor_hooks: ClassVar[set[EventHook]] = ...
    _node_preprocessor_hooks: ClassVar[set[NodeHook]] = ...
    _node_postprocessor_hooks: ClassVar[set[NodeHook]] = ...
    def __init__(self, *, config_file: str | None = ..., config_dict: dict[str, Any] | None = ..., handle_signals: bool = ...) -> None:
        """初始化 SekaiBot 核心实例，管理机器人生命周期和模块加载。

        Args:
            config_file: 配置文件路径，支持格式：
                - TOML (.toml)
                - JSON (.json)
                - YAML (.yml/.yaml)
                默认使用当前目录下的 config.toml
            config_dict: 直接传递配置字典，优先级高于 config_file
            handle_signals: 是否启用信号处理 (Ctrl+C 退出等)

        Attributes:
            config (MainConfig): 合并后的配置对象
            adapters (list[Adapter]): 已加载的协议适配器实例
            nodes (list[Node]): 已加载的业务节点列表
            plugins (dict[str, Plugin]): 已加载的插件字典

        Examples:
            ```python
            # 从默认配置文件启动
            bot = Bot()

            # 自定义配置启动
            bot = Bot(config_file="production.toml")

            # 完全自定义配置
            bot = Bot(config_dict={"bot": {"log": {"level": "DEBUG"}}})
            ```
        """
        ...
    
    @property
    def nodes(self) -> list[type[Node[Any, Any, Any]]]:
        """当前已经加载的节点的列表。"""
        ...
    
    def run(self) -> None:
        """运行 SekaiBot。"""
        ...
    
    async def arun(self) -> None:
        """异步运行 SekaiBot。"""
        ...
    
    def restart(self) -> None:
        """退出并重新运行 SekaiBot。"""
        ...
    
    async def startup(self) -> None:
        """加载或重加载 SekaiBot 的所有加载项"""
        ...
    
    def shutdown(self, *_args: Any) -> None:
        """当机器人收到退出信号时，根据情况进行处理。"""
        ...
    
    def load_nodes(self, *nodes: type[Node[Any, Any, Any]] | str | Path) -> None:
        """加载节点。

        Args:
            *nodes: 节点类、节点模块名称或者节点模块文件路径。
                类型可以是 `type[Node]`, `str` 或 `pathlib.Path`。
                如果为 `type[Node]` 类型时，将作为节点类进行加载。
                如果为 `str` 类型时，将作为节点模块名称进行加载，格式和 Python `import` 语句相同。
                    例如：`path.of.node`。
                如果为 `pathlib.Path` 类型时，将作为节点模块文件路径进行加载。
                    例如：`pathlib.Path("path/of/node")`。
        """
        ...
    
    def load_nodes_from_dirs(self, *dirs: Path) -> None:
        """从目录中加载节点，以 `_` 开头的模块中的节点不会被导入。路径可以是相对路径或绝对路径。

        Args:
            *dirs: 储存包含节点的模块的模块路径。
                例如：`pathlib.Path("path/of/nodes/")` 。
        """
        ...
    
    def get_node(self, name: str) -> type[Node[Any, Any, Any]]:
        """按照名称获取已经加载的插件类。

        Args:
            name: 插件名称

        Returns:
            获取到的插件类。

        Raises:
            LookupError: 找不到此名称的插件类。
        """
        ...
    
    def load_plugins(self) -> None:
        """加载插件。"""
        ...
    
    def get_plugin(self, name: str) -> Plugin[Any]:
        """按照名称获取已经加载的插件类。

        Args:
            name: 插件名称

        Returns:
            获取到的插件类。

        Raises:
            LookupError: 找不到此名称的插件类。
        """
        ...
    
    def load_adapters(self, *adapters: type[Adapter[Any, Any]] | str) -> None:
        """加载适配器。

        Args:
            *adapters: 适配器类或适配器名称，类型可以是 `Type[Adapter]` 或 `str`。
                如果为 `Type[Adapter]` 类型时，将作为适配器类进行加载。
                如果为 `str` 类型时，将作为适配器模块名称进行加载，格式和 Python `import` 语句相同。
                    例如：`path.of.adapter`。
        """
        ...
    
    @overload
    def get_adapter(self, adapter: str) -> Adapter[Any, Any]:
        ...
    
    @overload
    def get_adapter(self, adapter: type[AdapterT]) -> AdapterT:
        ...
    
    def get_adapter(self, adapter: str | type[AdapterT]) -> Adapter[Any, Any] | AdapterT:
        """按照名称或适配器类获取已经加载的适配器。

        Args:
            adapter: 适配器名称或适配器类。

        Returns:
            获取到的适配器对象。

        Raises:
            LookupError: 找不到此名称的适配器对象。
        """
        ...
    
    @classmethod
    def require_plugin(cls, plugin_class: type[Plugin[Any]]) -> None:
        """声明依赖插件。

        Args:
            plugin_class: 插件类。
            reload: 是否重加载。

        异常:
            RuntimeError: 插件无法加载
        """
        ...
    
    @classmethod
    def bot_startup_hook(cls, func: BotHook) -> BotHook:
        """注册一个 Bot 初始化时的函数。

        Args:
            func: 被注册的函数。

        Returns:
            被注册的函数。
        """
        ...
    
    @classmethod
    def bot_run_hook(cls, func: BotHook) -> BotHook:
        """注册一个 Bot 启动时的函数。

        Args:
            func: 被注册的函数。

        Returns:
            被注册的函数。
        """
        ...
    
    @classmethod
    def bot_exit_hook(cls, func: BotHook) -> BotHook:
        """注册一个 Bot 退出时的函数。

        Args:
            func: 被注册的函数。

        Returns:
            被注册的函数。
        """
        ...
    
    @classmethod
    def adapter_startup_hook(cls, func: AdapterHook) -> AdapterHook:
        """注册一个适配器初始化时的函数。

        Args:
            func: 被注册的函数。

        Returns:
            被注册的函数。
        """
        ...
    
    @classmethod
    def adapter_run_hook(cls, func: AdapterHook) -> AdapterHook:
        """注册一个适配器运行时的函数。

        Args:
            func: 被注册的函数。

        Returns:
            被注册的函数。
        """
        ...
    
    @classmethod
    def adapter_shutdown_hook(cls, func: AdapterHook) -> AdapterHook:
        """注册一个适配器关闭时的函数。

        Args:
            func: 被注册的函数。

        Returns:
            被注册的函数。
        """
        ...
    
    @classmethod
    def event_preprocessor_hook(cls, func: EventHook) -> EventHook:
        """注册一个事件预处理函数。

        Args:
            func: 被注册的函数。

        Returns:
            被注册的函数。
        """
        ...
    
    @classmethod
    def event_postprocessor_hook(cls, func: EventHook) -> EventHook:
        """注册一个事件后处理函数。

        Args:
            func: 被注册的函数。

        Returns:
            被注册的函数。
        """
        ...
    
    @classmethod
    def node_preprocessor_hook(cls, func: NodeHook) -> NodeHook:
        """注册一个节点运行预处理函数。

        Args:
            func: 被注册的函数。

        Returns:
            被注册的函数。
        """
        ...
    
    @classmethod
    def node_postprocessor_hook(cls, func: NodeHook) -> NodeHook:
        """注册一个节点运行后处理函数。

        Args:
            func: 被注册的函数。

        Returns:
            被注册的函数。
        """
        ...
    


