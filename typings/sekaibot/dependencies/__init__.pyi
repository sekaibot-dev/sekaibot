"""
This type stub file was generated by pyright.
"""

from contextlib import AsyncExitStack
from typing import Any, TYPE_CHECKING, TypeVar
from sekaibot.internal.event import Event
from sekaibot.typing import GlobalStateT, NodeStateT, StateT
from .utils import Dependency, InnerDepends, solve_dependencies
from sekaibot.bot import Bot

"""SekaiBot 依赖注入。

实现依赖注入相关功能。
"""
if TYPE_CHECKING:
    ...
_T = TypeVar("_T")
__all__ = ["Dependency", "Depends", "InnerDepends", "solve_dependencies", "solve_dependencies_in_bot"]
def Depends(dependency: Dependency[_T] | None = ..., *, use_cache: bool = ...) -> _T:
    """子依赖装饰器。

    Args:
        dependency: 依赖类。如果不指定则根据字段的类型注释自动判断。
        use_cache: 是否使用缓存。默认为 `True`。

    Returns:
        返回内部子依赖对象。
    """
    ...

async def solve_dependencies_in_bot(dependent: Dependency[_T], *, bot: Bot, event: Event[Any] | None = ..., state: StateT | None = ..., node_state: NodeStateT | None = ..., global_state: GlobalStateT | None = ..., use_cache: bool = ..., stack: AsyncExitStack | None = ..., dependency_cache: dict[Any, Any] | None = ...) -> _T:
    """解析子依赖。

    此方法强制要求 `bot`、`event`、`state`、`global_state` 作为参数，以确保依赖解析的严谨性。

    Args:
        dependent: 需要解析的依赖。
        bot: 机器人实例，必须提供。
        event: 事件对象，必须提供。
        state: 节点临时的状态信息，默认为 `None`。
        node_state: 节点持久化状态信息，可选，默认为 `None`。
        global_state: 为节点提供的全局状态，可选，默认为 `None`。
        use_cache: 是否使用缓存，默认为 `True`。
        stack: 异步上下文管理器，可选。
        dependency_cache: 依赖缓存，如果未提供，则自动创建新字典。

    Returns:
        解析后的依赖对象。
    """
    ...

