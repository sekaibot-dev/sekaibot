"""
This type stub file was generated by pyright.
"""

import json
import os
import anyio
from collections.abc import AsyncGenerator, Awaitable, Callable, Coroutine, Generator, Sequence
from contextlib import AbstractContextManager as ContextManager, asynccontextmanager
from importlib.abc import MetaPathFinder
from importlib.machinery import ModuleSpec
from types import ModuleType
from typing import Any, ClassVar, Literal, TYPE_CHECKING, TypeGuard, TypeVar, Union, overload
from typing_extensions import ParamSpec, override
from pydantic import BaseModel
from sekaibot.config import ConfigModel
from sekaibot.typing import EventT
from sekaibot.adapter import Adapter
from sekaibot.internal.event import Event

"""SekaiBot 内部使用的实用工具。"""
if TYPE_CHECKING:
    ...
__all__ = ["ModulePathFinder", "ModuleType", "PydanticEncoder", "TreeType", "cancel_on_exit", "flatten_exception_group", "flatten_tree_with_jumps", "get_annotations", "get_classes_from_module", "get_classes_from_module_name", "handle_exception", "is_config_class", "remove_none_attributes", "run_coro_with_catch", "samefile", "sync_ctx_manager_wrapper", "sync_func_wrapper", "wrap_get_func"]
_T = TypeVar("_T")
_P = ParamSpec("_P")
_R = TypeVar("_R")
_E = TypeVar("_E", bound=BaseException)
_TypeT = TypeVar("_TypeT", bound=type[Any])
_BaseModelT = TypeVar("_BaseModelT", bound=BaseModel)
StrOrBytesPath = Union[str, bytes, os.PathLike[Any]]
TreeType = dict[_T, Union[Any, "TreeType[_T]"]]
class ModulePathFinder(MetaPathFinder):
    """用于查找 KafuBot 组件的元路径查找器。"""
    path: ClassVar[list[str]] = ...
    @override
    def find_spec(self, fullname: str, path: Sequence[str] | None = ..., target: ModuleType | None = ...) -> ModuleSpec | None:
        """用于查找指定模块的 `spec`。"""
        ...
    


def is_config_class(config_class: Any) -> TypeGuard[type[ConfigModel]]:
    """判断一个对象是否是配置类。

    Args:
        config_class: 待判断的对象。

    Returns:
        返回是否是配置类。
    """
    ...

def remove_none_attributes(model: _BaseModelT, exclude: set[str] | None = ...) -> _BaseModelT:
    """去除类中值为None的属性

    Args:
        model: BaseModel的子类
        exclude: 无论是否为None都不去除的属性名

    Returns:
        返回是去除类中值为None的属性后的类。
    """
    ...

def get_classes_from_module(module: ModuleType, super_class: _TypeT) -> list[_TypeT]:
    """从模块中查找指定类型的类。

    Args:
        module: Python 模块。
        super_class: 要查找的类的超类。

    Returns:
        返回符合条件的类的列表。
    """
    ...

def get_classes_from_module_name(name: str, super_class: _TypeT, *, reload: bool = ...) -> list[tuple[_TypeT, ModuleType]]:
    """从指定名称的模块中查找指定类型的类。

    Args:
        name: 模块名称，格式和 Python `import` 语句相同。
        super_class: 要查找的类的超类。
        reload: 是否重新加载模块。

    Returns:
        返回由符合条件的类和模块组成的元组的列表。

    Raises:
        ImportError: 当导入模块过程中出现错误。
    """
    ...

def flatten_tree_with_jumps(tree: TreeType[_T]) -> list[tuple[_T, int]]:
    """将树按深度优先遍历展开，并计算剪枝后跳转索引。

    该函数遍历给定的树结构，并按深度优先遍历顺序生成节点列表。
    同时，为每个节点计算在剪枝后应跳转的索引，以便提高运行性能。

    适用于运行树，其中每个节点可能执行剪枝操作，剪枝后跳转到最近的兄弟节点，
    如果没有兄弟节点，则跳转到父节点的下一个兄弟节点。若无可跳转位置，则跳转至 -1 (表示终止) 。

    Args:
        tree: 一个字典形式的树，键代表节点，值可以是子树 (字典) 或叶子节点。

    Returns:
        一个列表，每个元素是一个元组 (节点, 剪枝后跳转索引)
        其中剪枝后跳转索引指向下一个可执行的节点，-1 表示无可跳转位置。
    """
    ...

def flatten_exception_group(exc_group: BaseExceptionGroup[_E]) -> Generator[_E, None, None]:
    """递归遍历 BaseExceptionGroup ，并返回一个生成器"""
    ...

def handle_exception(msg: str, level: Literal["debug", "info", "warning", "error", "critical"] = ..., **kwargs: Any) -> Callable[[BaseExceptionGroup[Exception]], None]:
    """递归遍历 BaseExceptionGroup ，并输出日志"""
    ...

@overload
async def run_coro_with_catch(coro: Coroutine[Any, Any, _T], exc: tuple[type[Exception], ...], return_on_err: None = ...) -> _T | None:
    ...

@overload
async def run_coro_with_catch(coro: Coroutine[Any, Any, _T], exc: tuple[type[Exception], ...], return_on_err: _R) -> _T | _R:
    ...

async def run_coro_with_catch(coro: Coroutine[Any, Any, _T], exc: tuple[type[Exception], ...], return_on_err: _R | None = ...) -> _T | _R | None:
    """运行协程并当遇到指定异常时返回指定值。

    Args:
        coro: 要运行的协程
        exc: 要捕获的异常
        return_on_err: 当发生异常时返回的值

    返回:
        协程的返回值或发生异常时的指定值
    """
    ...

class PydanticEncoder(json.JSONEncoder):
    """用于解析 `pydantic.BaseModel` 的 `JSONEncoder` 类。"""
    @override
    def default(self, o: Any) -> Any:
        """返回 `o` 的可序列化对象。"""
        ...
    


def samefile(path1: StrOrBytesPath, path2: StrOrBytesPath) -> bool:
    """一个 `os.path.samefile` 的简单包装。

    Args:
        path1: 路径1。
        path2: 路径2。

    Returns:
        如果两个路径是否指向相同的文件或目录。
    """
    ...

def sync_func_wrapper(func: Callable[_P, _R], *, to_thread: bool = ...) -> Callable[_P, Coroutine[None, None, _R]]:
    """包装一个同步函数为异步函数。

    Args:
        func: 待包装的同步函数。
        to_thread: 是否在独立的线程中运行同步函数。默认为 `False`。

    Returns:
        异步函数。
    """
    ...

@asynccontextmanager
async def sync_ctx_manager_wrapper(cm: ContextManager[_T], *, to_thread: bool = ...) -> AsyncGenerator[_T, None]:
    """将同步上下文管理器包装为异步上下文管理器。

    Args:
        cm: 待包装的同步上下文管理器。
        to_thread: 是否在独立的线程中运行同步函数。默认为 `False`。

    Returns:
        异步上下文管理器。
    """
    ...

def wrap_get_func(func: Callable[[EventT], bool | Awaitable[bool]] | None = ..., *, event_type: type[Event[Any]] | None = ..., adapter_type: type[Adapter[Any, Any]] | None = ...) -> Callable[[EventT], Awaitable[bool]]:
    """将 `get()` 函数接受的参数包装为一个异步函数。

    Args:
        func: `get()` 函数接受的参数。
        event_type: 事件类型。
        adapter_type: 适配器类型。

    Returns:
        异步函数。
    """
    ...

async def cancel_on_exit(condition: anyio.Event | anyio.Condition, cancel_scope: anyio.CancelScope) -> None:
    """当 should_exit 被设置时取消当前的 task group。

    支持 `anyio.Event` 和 `anyio.Condition`。
    """
    ...

