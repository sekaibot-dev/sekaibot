"""
This type stub file was generated by pyright.
"""

import os
import anyio
from abc import ABC, abstractmethod
from collections.abc import Awaitable, Callable
from typing import Any, ClassVar, Generic, Self, TYPE_CHECKING, final, overload
from exceptiongroup import catch
from sekaibot.exceptions import MockApiException
from sekaibot.internal.event import Event
from sekaibot.internal.message import BuildMessageType, MessageSegmentT
from sekaibot.log import logger
from sekaibot.typing import CalledAPIHook, CallingAPIHook, ConfigT, EventT
from sekaibot.utils import flatten_exception_group, handle_exception, is_config_class
from sekaibot.bot import Bot

"""AliceBot 协议适配器。

所有协议适配器都必须继承自 `Adapter` 基类。
"""
if TYPE_CHECKING:
    ...
__all__ = ["Adapter"]
if os.getenv("SEKAIBOT_DEV") == "1":
    ...
class Adapter(ABC, Generic[EventT, ConfigT]):
    """协议适配器基类。

    Attributes:
        name: 适配器的名称。
        bot: 当前的机器人对象。
    """
    name: str
    bot: Bot
    Config: type[ConfigT]
    _calling_api_hooks: ClassVar[set[CallingAPIHook]] = ...
    _called_api_hooks: ClassVar[set[CalledAPIHook]] = ...
    def __init__(self, bot: Bot) -> None:
        """初始化。

        Args:
            bot: 当前机器人对象。
        """
        ...
    
    @property
    def config(self) -> ConfigT:
        """适配器配置。"""
        ...
    
    @final
    async def safe_run(self) -> None:
        """附带有异常处理和重试机制的安全运行适配器。"""
        ...
    
    @abstractmethod
    async def run(self) -> None:
        """适配器运行方法，适配器开发者必须实现该方法。

        适配器运行过程中保持保持运行，当此方法结束后， AliceBot 不会自动重新启动适配器。
        """
        ...
    
    async def startup(self) -> None:
        """在适配器开始运行前运行的方法，用于初始化适配器。

        AliceBot 依次运行并等待所有适配器的 `startup()` 方法，待运行完毕后再创建 `run()` 任务。
        """
        ...
    
    async def shutdown(self) -> None:
        """在适配器结束运行时运行的方法，用于安全地关闭适配器。

        AliceBot 在接收到系统的结束信号后先发送 cancel 请求给 run 任务。
        在所有适配器都停止运行后，会依次运行并等待所有适配器的 `shutdown()` 方法。
        当强制退出时此方法可能未被执行。
        """
        ...
    
    async def call_api(self, api: str, **params: Any) -> Any:
        """调用机器人 API 接口，可以通过该函数或直接通过 bot 属性进行调用

        Args:
            api: API 名称
            params: API 数据

        用法:
            ```python
            await bot.call_api("send_msg", message="hello world")
            await bot.send_msg(message="hello world")
            ```
        """
        ...
    
    @abstractmethod
    async def send(self, event: Event[Self], message: BuildMessageType[MessageSegmentT], **kwargs: Any) -> Any:
        """调用机器人基础发送消息接口

        Args:
            event: 上报事件
            message: 要发送的消息
            kwargs: 任意额外参数
        """
        ...
    
    @overload
    async def get(self, func: Callable[[EventT], bool | Awaitable[bool]] | None = ..., *, event_type: None = ..., max_try_times: int | None = ..., timeout: float | None = ...) -> EventT:
        ...
    
    @overload
    async def get(self, func: Callable[[Event[Any]], bool | Awaitable[bool]] | None = ..., *, event_type: type[Event[Any]], max_try_times: int | None = ..., timeout: float | None = ...) -> Event[Any]:
        ...
    
    @final
    async def get(self, func: Callable[[Any], bool | Awaitable[bool]] | None = ..., *, event_type: Any = ..., max_try_times: int | None = ..., timeout: float | None = ...) -> Event[Any]:
        """获取满足指定条件的的事件，协程会等待直到适配器接收到满足条件的事件、超过最大事件数或超时。

        类似 `Bot` 类的 `get()` 方法，但是隐含了判断产生事件的适配器是本适配器。
        等效于 `Bot` 类的 `get()` 方法传入 adapter_type 为本适配器类型。

        Args:
            func: 协程或者函数，函数会被自动包装为协程执行。
                要求接受一个事件作为参数，返回布尔值。
                当协程返回 `True` 时返回当前事件。
                当为 `None` 时相当于输入对于任何事件均返回真的协程，即返回适配器接收到的下一个事件。
            event_type: 当指定时，只接受指定类型的事件，先于 func 条件生效。默认为 `None`。
            max_try_times: 最大事件数。
            timeout: 超时时间。

        Returns:
            返回满足 func 条件的事件。

        Raises:
            GetEventTimeout: 超过最大事件数或超时。
        """
        ...
    
    @classmethod
    def calling_api_hook(cls, func: CallingAPIHook) -> CallingAPIHook:
        """调用 api 预处理。

        钩子函数Args:

        - bot: 当前 bot 对象
        - api: 调用的 api 名称
        - data: api 调用的参数字典
        """
        ...
    
    @classmethod
    def called_api_hook(cls, func: CalledAPIHook) -> CalledAPIHook:
        """调用 api 后处理。

        钩子函数Args:

        - bot: 当前 bot 对象
        - exception: 调用 api 时发生的错误
        - api: 调用的 api 名称
        - data: api 调用的参数字典
        - result: api 调用的返回
        """
        ...
    


