"""
This type stub file was generated by pyright.
"""

import copy
from collections.abc import Generator, Hashable, Iterable
from functools import reduce
from itertools import cycle, product
from operator import add, mul
from typing import Any, Callable, Dict, Generic, List, TypeVar, Union, cast, overload

"""
Cycler
======

Cycling through combinations of values, producing dictionaries.

You can add cyclers::

    from cycler import cycler
    cc = (cycler(color=list('rgb')) +
          cycler(linestyle=['-', '--', '-.']))
    for d in cc:
        print(d)

Results in::

    {'color': 'r', 'linestyle': '-'}
    {'color': 'g', 'linestyle': '--'}
    {'color': 'b', 'linestyle': '-.'}


You can multiply cyclers::

    from cycler import cycler
    cc = (cycler(color=list('rgb')) *
          cycler(linestyle=['-', '--', '-.']))
    for d in cc:
        print(d)

Results in::

    {'color': 'r', 'linestyle': '-'}
    {'color': 'r', 'linestyle': '--'}
    {'color': 'r', 'linestyle': '-.'}
    {'color': 'g', 'linestyle': '-'}
    {'color': 'g', 'linestyle': '--'}
    {'color': 'g', 'linestyle': '-.'}
    {'color': 'b', 'linestyle': '-'}
    {'color': 'b', 'linestyle': '--'}
    {'color': 'b', 'linestyle': '-.'}
"""
__version__ = ...
K = TypeVar("K", bound=Hashable)
L = TypeVar("L", bound=Hashable)
V = TypeVar("V")
U = TypeVar("U")
def concat(left: Cycler[K, V], right: Cycler[K, U]) -> Cycler[K, V | U]:
    r"""
    Concatenate `Cycler`\s, as if chained using `itertools.chain`.

    The keys must match exactly.

    Examples
    --------
    >>> num = cycler('a', range(3))
    >>> let = cycler('a', 'abc')
    >>> num.concat(let)
    cycler('a', [0, 1, 2, 'a', 'b', 'c'])

    Returns
    -------
    `Cycler`
        The concatenated cycler.
    """
    ...

class Cycler(Generic[K, V]):
    """
    Composable cycles.

    This class has compositions methods:

    ``+``
      for 'inner' products (zip)

    ``+=``
      in-place ``+``

    ``*``
      for outer products (`itertools.product`) and integer multiplication

    ``*=``
      in-place ``*``

    and supports basic slicing via ``[]``.

    Parameters
    ----------
    left, right : Cycler or None
        The 'left' and 'right' cyclers.
    op : func or None
        Function which composes the 'left' and 'right' cyclers.
    """
    def __call__(self): # -> cycle[dict[K, V]]:
        ...
    
    def __init__(self, left: Cycler[K, V] | Iterable[dict[K, V]] | None, right: Cycler[K, V] | None = ..., op: Any = ...) -> None:
        """
        Semi-private init.

        Do not use this directly, use `cycler` function instead.
        """
        ...
    
    def __contains__(self, k): # -> bool:
        ...
    
    @property
    def keys(self) -> set[K]:
        """The keys this Cycler knows about."""
        ...
    
    def change_key(self, old: K, new: K) -> None:
        """
        Change a key in this cycler to a new name.
        Modification is performed in-place.

        Does nothing if the old key is the same as the new key.
        Raises a ValueError if the new key is already a key.
        Raises a KeyError if the old key isn't a key.
        """
        ...
    
    def __getitem__(self, key: slice) -> Cycler[K, V]:
        ...
    
    def __iter__(self) -> Generator[dict[K, V], None, None]:
        ...
    
    def __add__(self, other: Cycler[L, U]) -> Cycler[K | L, V | U]:
        """
        Pair-wise combine two equal length cyclers (zip).

        Parameters
        ----------
        other : Cycler
        """
        ...
    
    @overload
    def __mul__(self, other: Cycler[L, U]) -> Cycler[K | L, V | U]:
        ...
    
    @overload
    def __mul__(self, other: int) -> Cycler[K, V]:
        ...
    
    def __mul__(self, other): # -> Cycler[K | L, V | U] | Any | _NotImplementedType:
        """
        Outer product of two cyclers (`itertools.product`) or integer
        multiplication.

        Parameters
        ----------
        other : Cycler or int
        """
        ...
    
    @overload
    def __rmul__(self, other: Cycler[L, U]) -> Cycler[K | L, V | U]:
        ...
    
    @overload
    def __rmul__(self, other: int) -> Cycler[K, V]:
        ...
    
    def __rmul__(self, other):
        ...
    
    def __len__(self) -> int:
        ...
    
    def __iadd__(self, other: Cycler[K, V]) -> Cycler[K, V]:
        """
        In-place pair-wise combine two equal length cyclers (zip).

        Parameters
        ----------
        other : Cycler
        """
        ...
    
    def __imul__(self, other: Cycler[K, V] | int) -> Cycler[K, V]:
        """
        In-place outer product of two cyclers (`itertools.product`).

        Parameters
        ----------
        other : Cycler
        """
        ...
    
    def __eq__(self, other: object) -> bool:
        ...
    
    __hash__ = ...
    def __repr__(self) -> str:
        ...
    
    def by_key(self) -> dict[K, list[V]]:
        """
        Values by key.

        This returns the transposed values of the cycler.  Iterating
        over a `Cycler` yields dicts with a single value for each key,
        this method returns a `dict` of `list` which are the values
        for the given key.

        The returned value can be used to create an equivalent `Cycler`
        using only `+`.

        Returns
        -------
        transpose : dict
            dict of lists of the values for each key.
        """
        ...
    
    _transpose = ...
    def simplify(self) -> Cycler[K, V]:
        """
        Simplify the cycler into a sum (but no products) of cyclers.

        Returns
        -------
        simple : Cycler
        """
        ...
    
    concat = ...


@overload
def cycler(arg: Cycler[K, V]) -> Cycler[K, V]:
    ...

@overload
def cycler(**kwargs: Iterable[V]) -> Cycler[str, V]:
    ...

@overload
def cycler(label: K, itr: Iterable[V]) -> Cycler[K, V]:
    ...

def cycler(*args, **kwargs): # -> Cycler[Any, Any] | Any:
    """
    Create a new `Cycler` object from a single positional argument,
    a pair of positional arguments, or the combination of keyword arguments.

    cycler(arg)
    cycler(label1=itr1[, label2=iter2[, ...]])
    cycler(label, itr)

    Form 1 simply copies a given `Cycler` object.

    Form 2 composes a `Cycler` as an inner product of the
    pairs of keyword arguments. In other words, all of the
    iterables are cycled simultaneously, as if through zip().

    Form 3 creates a `Cycler` from a label and an iterable.
    This is useful for when the label cannot be a keyword argument
    (e.g., an integer or a name that has a space in it).

    Parameters
    ----------
    arg : Cycler
        Copy constructor for Cycler (does a shallow copy of iterables).
    label : name
        The property key. In the 2-arg form of the function,
        the label can be any hashable object. In the keyword argument
        form of the function, it must be a valid python identifier.
    itr : iterable
        Finite length iterable of the property values.
        Can be a single-property `Cycler` that would
        be like a key change, but as a shallow copy.

    Returns
    -------
    cycler : Cycler
        New `Cycler` for the given property

    """
    ...

