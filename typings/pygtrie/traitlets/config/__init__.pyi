"""
This type stub file was generated by pyright.
"""

import functools
import json
import logging
import os
import pprint
import re
import sys
import typing as t
from collections import OrderedDict, defaultdict
from contextlib import suppress
from copy import deepcopy
from logging.config import dictConfig
from textwrap import dedent
from traitlets.config.configurable import Configurable, SingletonConfigurable
from traitlets.config.loader import ArgumentError, Config, ConfigFileNotFound, DeferredConfigString, JSONFileConfigLoader, KVArgParseConfigLoader, PyFileConfigLoader
from traitlets.traitlets import Bool, Dict, Enum, Instance, List, TraitError, Unicode, default, observe, observe_compat
from traitlets.utils.bunch import Bunch
from traitlets.utils.nested_update import nested_update
from traitlets.utils.text import indent, wrap_paragraphs
from ..utils import cast_unicode
from ..utils.importstring import import_item

"""A base class for a configurable application."""
option_description = ...
keyvalue_description = ...
if not hasattr(sys, "argv"):
    ...
subcommand_description = ...
_envvar = ...
if _envvar.lower() in "1", "true":
    TRAITLETS_APPLICATION_RAISE_CONFIG_FILE_ERROR = ...
else:
    TRAITLETS_APPLICATION_RAISE_CONFIG_FILE_ERROR = ...
IS_PYTHONW = ...
T = t.TypeVar("T", bound=t.Callable[..., t.Any])
AnyLogger = t.Union[logging.Logger, "logging.LoggerAdapter[t.Any]"]
StrDict = t.Dict[str, t.Any]
ArgvType = t.Optional[t.List[str]]
ClassesType = t.List[t.Type[Configurable]]
def catch_config_error(method: T) -> T:
    """Method decorator for catching invalid config (Trait/ArgumentErrors) during init.

    On a TraitError (generally caused by bad config), this will print the trait's
    message, and exit the app.

    For use on init methods, to prevent invoking excepthook on invalid input.
    """
    ...

class ApplicationError(Exception):
    ...


class LevelFormatter(logging.Formatter):
    """Formatter with additional `highlevel` record

    This field is empty if log level is less than highlevel_limit,
    otherwise it is formatted with self.highlevel_format.

    Useful for adding 'WARNING' to warning messages,
    without adding 'INFO' to info, etc.
    """
    highlevel_limit = ...
    highlevel_format = ...
    def format(self, record: logging.LogRecord) -> str:
        ...
    


class Application(SingletonConfigurable):
    """A singleton application with full configuration support."""
    name: str | Unicode[str, str | bytes] = ...
    description: str | Unicode[str, str | bytes] = ...
    option_description: str | Unicode[str, str | bytes] = ...
    keyvalue_description: str | Unicode[str, str | bytes] = ...
    subcommand_description: str | Unicode[str, str | bytes] = ...
    python_config_loader_class = PyFileConfigLoader
    json_config_loader_class = JSONFileConfigLoader
    examples: str | Unicode[str, str | bytes] = ...
    classes: ClassesType = ...
    version: str | Unicode[str, str | bytes] = ...
    argv: list[str] | List[str] = ...
    raise_config_file_errors = ...
    log_level = ...
    _log_formatter_cls = LevelFormatter
    log_datefmt = ...
    log_format = ...
    def get_default_logging_config(self) -> StrDict:
        """Return the base logging configuration.

        The default is to log to stderr using a StreamHandler, if no default
        handler already exists.

        The log handler level starts at logging.WARN, but this can be adjusted
        by setting the ``log_level`` attribute.

        The ``logging_config`` trait is merged into this allowing for finer
        control of logging.

        """
        ...
    
    logging_config = ...
    aliases: StrDict = ...
    flags: StrDict = ...
    subcommands: dict[str, t.Any] | Dict[str, t.Any] = ...
    subapp = ...
    extra_args = ...
    cli_config = ...
    _loaded_config_files: List[str] = ...
    show_config = ...
    show_config_json = ...
    def __init__(self, **kwargs: t.Any) -> None:
        ...
    
    @catch_config_error
    def initialize(self, argv: ArgvType = ...) -> None:
        """Do the basic steps to configure me.

        Override in subclasses.
        """
        ...
    
    def start(self) -> None:
        """Start the app mainloop.

        Override in subclasses.
        """
        ...
    
    def start_show_config(self) -> None:
        """start function used when show_config is True"""
        ...
    
    def print_alias_help(self) -> None:
        """Print the alias parts of the help."""
        ...
    
    def emit_alias_help(self) -> t.Generator[str, None, None]:
        """Yield the lines for alias part of the help."""
        ...
    
    def print_flag_help(self) -> None:
        """Print the flag part of the help."""
        ...
    
    def emit_flag_help(self) -> t.Generator[str, None, None]:
        """Yield the lines for the flag part of the help."""
        ...
    
    def print_options(self) -> None:
        """Print the options part of the help."""
        ...
    
    def emit_options_help(self) -> t.Generator[str, None, None]:
        """Yield the lines for the options part of the help."""
        ...
    
    def print_subcommands(self) -> None:
        """Print the subcommand part of the help."""
        ...
    
    def emit_subcommands_help(self) -> t.Generator[str, None, None]:
        """Yield the lines for the subcommand part of the help."""
        ...
    
    def emit_help_epilogue(self, classes: bool) -> t.Generator[str, None, None]:
        """Yield the very bottom lines of the help message.

        If classes=False (the default), print `--help-all` msg.
        """
        ...
    
    def print_help(self, classes: bool = ...) -> None:
        """Print the help for each Configurable class in self.classes.

        If classes=False (the default), only flags and aliases are printed.
        """
        ...
    
    def emit_help(self, classes: bool = ...) -> t.Generator[str, None, None]:
        """Yield the help-lines for each Configurable class in self.classes.

        If classes=False (the default), only flags and aliases are printed.
        """
        ...
    
    def document_config_options(self) -> str:
        """Generate rST format documentation for the config options this application

        Returns a multiline string.
        """
        ...
    
    def print_description(self) -> None:
        """Print the application description."""
        ...
    
    def emit_description(self) -> t.Generator[str, None, None]:
        """Yield lines with the application description."""
        ...
    
    def print_examples(self) -> None:
        """Print usage and examples (see `emit_examples()`)."""
        ...
    
    def emit_examples(self) -> t.Generator[str, None, None]:
        """Yield lines with the usage and examples.

        This usage string goes at the end of the command line help string
        and should contain examples of the application's usage.
        """
        ...
    
    def print_version(self) -> None:
        """Print the version string."""
        ...
    
    @catch_config_error
    def initialize_subcommand(self, subc: str, argv: ArgvType = ...) -> None:
        """Initialize a subcommand with argv."""
        ...
    
    def flatten_flags(self) -> tuple[dict[str, t.Any], dict[str, t.Any]]:
        """Flatten flags and aliases for loaders, so cl-args override as expected.

        This prevents issues such as an alias pointing to InteractiveShell,
        but a config file setting the same trait in TerminalInteraciveShell
        getting inappropriate priority over the command-line arg.
        Also, loaders expect ``(key: longname)`` and not ``key: (longname, help)`` items.

        Only aliases with exactly one descendent in the class list
        will be promoted.

        """
        ...
    
    @catch_config_error
    def parse_command_line(self, argv: ArgvType = ...) -> None:
        """Parse the command line arguments."""
        ...
    
    @property
    def loaded_config_files(self) -> list[str]:
        """Currently loaded configuration files"""
        ...
    
    @catch_config_error
    def load_config_file(self, filename: str, path: str | t.Sequence[str | None] | None = ...) -> None:
        """Load config files by filename and path."""
        ...
    
    @catch_config_error
    def load_config_environ(self) -> None:
        """Load config files by environment."""
        ...
    
    def generate_config_file(self, classes: ClassesType | None = ...) -> str:
        """generate default config file from Configurables"""
        ...
    
    def close_handlers(self) -> None:
        ...
    
    def exit(self, exit_status: int | str | None = ...) -> None:
        ...
    
    def __del__(self) -> None:
        ...
    
    @classmethod
    def launch_instance(cls, argv: ArgvType = ..., **kwargs: t.Any) -> None:
        """Launch a global instance of this Application

        If a global instance already exists, this reinitializes and starts it
        """
        ...
    


default_aliases = Application.aliases
default_flags = Application.flags
def boolean_flag(name: str, configurable: str, set_help: str = ..., unset_help: str = ...) -> StrDict:
    """Helper for building basic --trait, --no-trait flags.

    Parameters
    ----------
    name : str
        The name of the flag.
    configurable : str
        The 'Class.trait' string of the trait to be set/unset with the flag
    set_help : unicode
        help string for --name flag
    unset_help : unicode
        help string for --no-name flag

    Returns
    -------
    cfg : dict
        A dict with two keys: 'name', and 'no-name', for setting and unsetting
        the trait, respectively.
    """
    ...

def get_config() -> Config:
    """Get the config object for the global Application instance, if there is one

    otherwise return an empty config object
    """
    ...

if __name__ == "__main__":
    ...
