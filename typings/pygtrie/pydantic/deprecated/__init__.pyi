"""
This type stub file was generated by pyright.
"""

import datetime
import warnings
from collections import deque
from decimal import Decimal
from enum import Enum
from ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network
from pathlib import Path
from re import Pattern
from types import GeneratorType
from typing import Any, Callable, Dict, TYPE_CHECKING, Type, Union
from uuid import UUID
from typing_extensions import deprecated
from .._internal._import_utils import import_cached_base_model
from ..color import Color
from ..networks import NameEmail
from ..types import SecretBytes, SecretStr
from ..warnings import PydanticDeprecatedSince20

if not TYPE_CHECKING:
    ...
__all__ = ('pydantic_encoder', 'custom_pydantic_encoder', 'timedelta_isoformat')
def isoformat(o: Union[datetime.date, datetime.time]) -> str:
    ...

def decimal_encoder(dec_value: Decimal) -> Union[int, float]:
    """Encodes a Decimal as int of there's no exponent, otherwise float.

    This is useful when we use ConstrainedDecimal to represent Numeric(x,0)
    where a integer (but not int typed) is used. Encoding this as a float
    results in failed round-tripping between encode and parse.
    Our Id type is a prime example of this.

    >>> decimal_encoder(Decimal("1.0"))
    1.0

    >>> decimal_encoder(Decimal("1"))
    1
    """
    ...

ENCODERS_BY_TYPE: Dict[Type[Any], Callable[[Any], Any]] = ...
@deprecated('`pydantic_encoder` is deprecated, use `pydantic_core.to_jsonable_python` instead.', category=None)
def pydantic_encoder(obj: Any) -> Any:
    ...

@deprecated('`custom_pydantic_encoder` is deprecated, use `BaseModel.model_dump` instead.', category=None)
def custom_pydantic_encoder(type_encoders: Dict[Any, Callable[[Type[Any]], Any]], obj: Any) -> Any:
    ...

@deprecated('`timedelta_isoformat` is deprecated.', category=None)
def timedelta_isoformat(td: datetime.timedelta) -> str:
    """ISO 8601 encoding for Python timedelta object."""
    ...

