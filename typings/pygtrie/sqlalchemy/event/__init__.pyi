"""
This type stub file was generated by pyright.
"""

import collections
import types
import typing
import weakref
from typing import Any, Callable, Deque, Dict, Generic, Iterable, Optional, Tuple, TypeVar, Union, cast
from .. import exc, util
from .attr import RefCollection
from .base import dispatcher

"""Provides managed registration services on behalf of :func:`.listen`
arguments.

By "managed registration", we mean that event listening functions and
other objects can be added to various collections in such a way that their
membership in all those collections can be revoked at once, based on
an equivalent :class:`._EventKey`.

"""
if typing.TYPE_CHECKING:
    ...
_ListenerFnType = Callable[..., Any]
_ListenerFnKeyType = Union[int, Tuple[int, int]]
_EventKeyTupleType = Tuple[int, str, _ListenerFnKeyType]
_ET = TypeVar("_ET", bound="EventTarget")
class EventTarget:
    """represents an event target, that is, something we can listen on
    either with that target as a class or as an instance.

    Examples include:  Connection, Mapper, Table, Session,
    InstrumentedAttribute, Engine, Pool, Dialect.

    """
    __slots__ = ...
    dispatch: dispatcher[Any]


_RefCollectionToListenerType = Dict["weakref.ref[RefCollection[Any]]", "weakref.ref[_ListenerFnType]",]
_key_to_collection: Dict[_EventKeyTupleType, _RefCollectionToListenerType] = ...
_ListenerToEventKeyType = Dict["weakref.ref[_ListenerFnType]", _EventKeyTupleType,]
_collection_to_key: Dict[weakref.ref[RefCollection[Any]], _ListenerToEventKeyType,] = ...
class _EventKey(Generic[_ET]):
    """Represent :func:`.listen` arguments."""
    __slots__ = ...
    target: _ET
    identifier: str
    fn: _ListenerFnType
    fn_key: _ListenerFnKeyType
    dispatch_target: Any
    _fn_wrap: Optional[_ListenerFnType]
    def __init__(self, target: _ET, identifier: str, fn: _ListenerFnType, dispatch_target: Any, _fn_wrap: Optional[_ListenerFnType] = ...) -> None:
        ...
    
    def with_wrapper(self, fn_wrap: _ListenerFnType) -> _EventKey[_ET]:
        ...
    
    def with_dispatch_target(self, dispatch_target: Any) -> _EventKey[_ET]:
        ...
    
    def listen(self, *args: Any, **kw: Any) -> None:
        ...
    
    def remove(self) -> None:
        ...
    
    def contains(self) -> bool:
        """Return True if this event key is registered to listen."""
        ...
    
    def base_listen(self, propagate: bool = ..., insert: bool = ..., named: bool = ..., retval: Optional[bool] = ..., asyncio: bool = ...) -> None:
        ...
    
    def append_to_list(self, owner: RefCollection[_ET], list_: Deque[_ListenerFnType]) -> bool:
        ...
    
    def remove_from_list(self, owner: RefCollection[_ET], list_: Deque[_ListenerFnType]) -> None:
        ...
    
    def prepend_to_list(self, owner: RefCollection[_ET], list_: Deque[_ListenerFnType]) -> bool:
        ...
    


